grammar org.emoflon.cep.Grapel with org.emoflon.ibex.gt.editor.GT

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.emoflon.org/ibex/gt/editor/GT" as GT

generate grapel "http://www.emoflon.org/cep/Grapel"  

@Override 
EditorGTFile: {EditorGTFile} 
	(imports+=EditorImport)*
  	(patterns+=EditorPattern |
  	conditions+=EditorCondition |
  	attributeConditionLibraries+=EditorAttributeConditionLibrary |
  	events += Event |
  	evenPatterns += EventPattern)*
  	
;

Event:
	'event' name=ID '{'
	(attributes += EventAttribute)*
	'}'
;

EventAttribute:
	type=[ecore::EDataType] | type=[ecore::EClass] name=ID ';' 
;

EventPattern:
	'event_pattern' name=ID (returnType=ReturnType)?'{'
	(nodes += EventPatternNode)*
	(contextConstraints += EventPatternContextConstraint)*
	relationalConstraints += EventPatternRelationalConstraint 
		(relConstraintRelations += RelationalConstraintRelation 
			relationalConstraints += EventPatternRelationalConstraint)*
	
	(returnStatement = ReturnStatement)?
	'}'
;

ReturnType:
	'spawns' returnType=[Event|ID]
;

ReturnStatement:
	'spawn' returnArg=[Event|ID]'('
		(returnParams+=AttributeExpression 
			(',' returnParams+=AttributeExpression)* 
		)?
	')'
;

EventPatternNode:
	name=ID ':' type=[Event|ID] | type=[GT::EditorPattern|ID]
;

EventPatternNodeExpression:
	patternNode = [EventPatternNode|ID] ('.' attribute = [EventAttribute|ID] | attribute = [GT::EditorNode|ID])
;

EventPatternNodeAttributeExpression:
	nodeExpression = EventPatternNodeExpression ('.' field = [ecore::EAttribute|ID])?
;

EventPatternContextConstraint:
//	lhs = EventPatternNodeAttributeExpression
	lhs = EventPatternNodeExpression
	relation = ContextRelation
//	rhs = EventPatternNodeAttributeExpression
	rhs = EventPatternNodeExpression
;

enum ContextRelation:
	EQUAL='==' |
  UNEQUAL='!=' 
;

enum RelationalConstraintRelation:
	AND='AND' |
  	OR='OR' 
;

EventPatternRelationalConstraint:
	operands +=  [EventPatternNode|ID] (operators += RelationalOperator operands += [EventPatternNode|ID])* '{'
		(constraints += AttributeConstraint (relations += AttributeConstraintRelation 
				constraints += AttributeConstraint)*
		)?
	'}'
;

enum RelationalOperator:
	AND='&&' |
  	OR='||' |
  	FOLLOWS='->' 
;

AttributeConstraint:
	 lhs = AttributeExpression relation = AttributeRelation rhs = AttributeExpression
;

enum AttributeConstraintRelation:
  AND='&&' |
  	OR='||' 
;

enum AttributeRelation:
  GREATER='>' |
  GREATER_OR_EQUAL='>=' |
  EQUAL='==' |
  UNEQUAL='!=' |
  SMALLER_OR_EQUAL='<=' |
  SMALLER='<'
;

//enum NegationOperators:
//	RELATIONAL_NEGATION='NOT' |
//	LOGICAL_NEGATION='!'
//;

//enum Brackets:
//	ROUNDL='(' |
//	ROUNDR=')'
//;

AttributeExpression:
	operands+=AttributeExpressionOperand 
		(operators+= ArithmeticOperator
			operands+=AttributeExpressionOperand
		)*
;

AttributeExpressionOperand:
	AttributeExpressionLiteral | EventPatternNodeAttributeExpression
;

AttributeExpressionLiteral:
	NumberLiteral  | StringLiteral | BooleanLiteral
;

NumberLiteral:
	DoubleLiteral | IntegerLiteral
;

DoubleLiteral:
	value = Double
;

IntegerLiteral:
	value = Integer
;

StringLiteral:
	value = STRING
;

BooleanLiteral:
	value = BOOLEAN
;

Double returns ecore::EDouble:
	('-')?INT '.' INT
;

//UnsignedInteger returns ecore::EInt:
//	INT
//;

Integer returns ecore::EInt:
	(('-')? INT)
;

@Override
terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9')*
;

@Override
terminal STRING returns ecore::EString:
	'"' ( '""' | !('"') )* '"'
;

BOOLEAN returns ecore::EBoolean:
	TRUE | FALSE
;

terminal TRUE returns ecore::EBoolean:
	'true'
;

terminal FALSE returns ecore::EBoolean:
	'false'
;

enum ArithmeticOperator:
  PLUS='+' |
  MINUS='-' |
  MULTIPLY='*' |
  DIVIDE='/'
;
