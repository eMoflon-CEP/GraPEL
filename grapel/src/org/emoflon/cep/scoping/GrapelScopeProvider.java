/*
 * generated by Xtext 2.20.0
 */
package org.emoflon.cep.scoping;

import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.cep.grapel.AttributeConstraint;
import org.emoflon.cep.grapel.AttributeExpression;
import org.emoflon.cep.grapel.EditorGTFile;
import org.emoflon.cep.grapel.Event;
import org.emoflon.cep.grapel.EventAttribute;
import org.emoflon.cep.grapel.EventPattern;
import org.emoflon.cep.grapel.EventPatternContextConstraint;
import org.emoflon.cep.grapel.EventPatternNode;
import org.emoflon.cep.grapel.EventPatternNodeAttributeExpression;
import org.emoflon.cep.grapel.EventPatternRelationalConstraint;
import org.emoflon.cep.grapel.GrapelPackage;
import org.emoflon.cep.grapel.impl.EventPatternImpl;
import org.emoflon.ibex.gt.editor.gT.EditorNode;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.gT.GTPackage;
import org.emoflon.ibex.gt.editor.utils.GTEditorModelUtils;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GrapelScopeProvider extends AbstractGrapelScopeProvider {
	@Override
	public IScope getScope(EObject context, EReference reference) {	
		// Events
	    if (isEvent(context, reference)) {
	    	return getScopeForEvents((Event)context);
	    }
	    // EventAttributes
	    if (isEventAttribute(context, reference)) {
	    	return getScopeForEventAttributes((EventAttribute)context);
		}
	    // EventPatterns
	    if (isEventPattern(context, reference)) {
	    	return getScopeForEventPatterns((EventPattern)context, reference);
		}
	    // EventPatternReturnTypes
	    if (isEventPatternReturnType(context, reference)) {
	    	return getScopeForEventPatternReturnTypes((EventPattern)context, reference);
		}
	    // EventPatternNodes
	    if (isEventPatternNode(context, reference)) {
	    	return getScopeForEventPatternNodes((EventPatternNode)context);
		}
	    // EventPatternContextConstraints
	    if (isEventPatternContextConstraint(context, reference)) {
	    	return getScopeForEventPatternContextConstraintNodes((EventPatternContextConstraint)context);
		}
	    // EventPatternNodeAttributeExpression
	    if (isEventPatternNodeAttributeExpression(context, reference)) {
	    	return getScopeForEventPatternNodeAttributeExpressions((EventPatternNodeAttributeExpression)context);
		}
	    // EventPatternNodeAttributeExpressionAttribute
	    if (isEventPatternNodeAttributeExpressionAttribute(context, reference)) {
	    	return getScopeForEventPatternNodeAttributeExpressionAttributes((EventPatternNodeAttributeExpression)context, reference);
		}
	    // EventPatternNodeAttributeExpressionField
	    if (isEventPatternNodeAttributeExpressionAttributeField(context, reference)) {
	    	return getScopeForEventPatternNodeAttributeExpressionAttributeFields((EventPatternNodeAttributeExpression)context, reference);
		}
	    // EventPatternRelationalConstraint
	    if (isEventPatternRelationalConstraint(context, reference)) {
	    	return getScopeForEventPatternRelationalConstraints((EventPatternRelationalConstraint)context, reference);
		}
	    // AttributeConstraint
	    if (isAttributeConstraint(context, reference)) {
	    	return getScopeForAttributeConstraints((AttributeConstraint)context, reference);
		}
	    // AttributeExpression
	    if (isAttributeExpression(context, reference)) {
	    	return getScopeForAttributeExpressions((AttributeExpression)context, reference);
		}
	    return super.getScope(context, reference);
	}
	
	private IScope getScopeForAttributeExpressions(AttributeExpression context, EReference reference) {
		return Scopes.scopeFor(getContainer(context, EventPatternImpl.class).getNodes());
	}

	private boolean isAttributeExpression(EObject context, EReference reference) {
		 return (context instanceof AttributeExpression);
	}

	private boolean isEventPatternReturnType(EObject context, EReference reference) {
		 return (context instanceof EventPattern && 
				 (reference == GrapelPackage.Literals.EVENT_PATTERN__RETURN_TYPE || reference == GrapelPackage.Literals.EVENT_PATTERN__RETURN_STATEMENT));
	}
	
	protected IScope getScopeForEventPatternReturnTypes(EventPattern context, EReference reference) {
		return Scopes.scopeFor(getGTFile(context).getEvents());
	}

	private IScope getScopeForAttributeConstraints(AttributeConstraint context, EReference reference) {
		return Scopes.scopeFor(getContainer(context, EventPatternImpl.class).getNodes());
	}

	private boolean isAttributeConstraint(EObject context, EReference reference) {
		return (context instanceof AttributeConstraint);
	}

	private IScope getScopeForEventPatternRelationalConstraints(EventPatternRelationalConstraint context,
			EReference reference) {
		EventPattern ePattern = (EventPattern)context.eContainer();
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(ePattern.getNodes());
		return Scopes.scopeFor(scope);
	}

	private boolean isEventPatternRelationalConstraint(EObject context, EReference reference) {
		return (context instanceof EventPatternRelationalConstraint);
	}

	private IScope getScopeForEventPatternNodeAttributeExpressionAttributeFields(
			EventPatternNodeAttributeExpression context, EReference reference) {
		Collection<EObject> scope = new HashSet<>();
		//scope.add();
		if(context.getAttributeExpression() == null)
			return super.getScope(context, reference);
		if(context.getAttribute() == null)
			return super.getScope(context, reference);
		if(context.getAttribute().eContainer() == null)
			return super.getScope(context, reference);
		
		if(context.getAttributeExpression().getType() instanceof Event) {
			EventAttribute attribute = (EventAttribute)context.getAttribute();
			
			if(attribute.getType() instanceof EDataType)
				return super.getScope(context, reference);
			
			EClass clazz = (EClass)attribute.getType();
			scope.addAll(clazz.getEAllAttributes());
		}else {
			EditorNode node = (EditorNode) context.getAttribute();
			scope.addAll(node.getType().getEAllAttributes());
		}
		return Scopes.scopeFor(scope);
	}

	private boolean isEventPatternNodeAttributeExpressionAttributeField(EObject context, EReference reference) {
		return (context instanceof EventPatternNodeAttributeExpression 
				&& reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_ATTRIBUTE_EXPRESSION__FIELD);
	}

	private IScope getScopeForEventPatternNodeAttributeExpressionAttributes(
			EventPatternNodeAttributeExpression context, EReference reference) {
		Collection<EObject> scope = new HashSet<>();
		//scope.add();
		if(context.getAttributeExpression() == null)
			return super.getScope(context, reference);
		if(context.getAttributeExpression().getType() instanceof Event) {
			Event event = (Event)context.getAttributeExpression().getType();
			scope.addAll(event.getAttributes());
		}else {
			EditorPattern pattern = (EditorPattern) context.getAttributeExpression().getType();
			scope.addAll(pattern.getNodes());
		}
		
		return Scopes.scopeFor(scope);
	}

	private boolean isEventPatternNodeAttributeExpressionAttribute(EObject context, EReference reference) {
		return (context instanceof EventPatternNodeAttributeExpression 
				&& reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_ATTRIBUTE_EXPRESSION__ATTRIBUTE);
	}

	private IScope getScopeForEventPatternNodeAttributeExpressions(EventPatternNodeAttributeExpression context) {
//		return Scopes.scopeFor(((EventPattern)context.eContainer().eContainer()).getNodes());
		return Scopes.scopeFor(getContainer(context, EventPatternImpl.class).getNodes());
	}

	private boolean isEventPatternNodeAttributeExpression(EObject context, EReference reference) {
		return (context instanceof EventPatternNodeAttributeExpression 
				&& reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_ATTRIBUTE_EXPRESSION__ATTRIBUTE_EXPRESSION);
	}

	private IScope getScopeForEventPatternContextConstraintNodes(EventPatternContextConstraint context) {
		return Scopes.scopeFor(((EventPattern)context.eContainer()).getNodes());
	}

	private boolean isEventPatternContextConstraint(EObject context, EReference reference) {
		return (context instanceof EventPatternContextConstraint);
	}

	protected boolean isEvent(EObject context, EReference reference) {
	    return (context instanceof Event);
	}
	
	protected IScope getScopeForEvents(Event context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(GTEditorModelUtils.getClasses(getGTFile(context)));
		scope.addAll(GTEditorModelUtils.getDatatypes(getGTFile(context)));
		return Scopes.scopeFor(scope);
	}
	
	protected boolean isEventAttribute(EObject context, EReference reference) {
	    return (context instanceof EventAttribute && reference == GrapelPackage.Literals.EVENT_ATTRIBUTE__TYPE);
	}
	
	protected IScope getScopeForEventAttributes(EventAttribute context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(GTEditorModelUtils.getClasses(getGTFile(context)));
		scope.addAll(GTEditorModelUtils.getDatatypes(getGTFile(context)));
		return Scopes.scopeFor(scope);
	}
	
	protected boolean isEventPattern(EObject context, EReference reference) {
	    return (context instanceof EventPattern && reference != GrapelPackage.Literals.EVENT_PATTERN__RETURN_TYPE
//	    		&& reference != GrapelPackage.Literals.EVENT_PATTERN__RETURN_ARG
//	    		&& reference != GrapelPackage.Literals.EVENT_PATTERN__RETURN_PARAMS
	    		);
	}
	
	protected IScope getScopeForEventPatterns(EventPattern context, EReference reference) {
		return Scopes.scopeFor(context.getNodes());
	}
	
	protected boolean isEventPatternNode(EObject context, EReference reference) {
	    return (context instanceof EventPatternNode && reference == GrapelPackage.Literals.EVENT_PATTERN_NODE__TYPE);
	}
	
	protected IScope getScopeForEventPatternNodes(EventPatternNode context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(getGTFile(context).getPatterns());
		scope.addAll(getGTFile(context).getEvents());
		return Scopes.scopeFor(scope);
	}
	
	@SuppressWarnings("unchecked")
	public static <T> T getContainer(EObject node, Class<T> clazz) {
		EObject current = node;
		while(!(current.getClass() == clazz)) {
			if(node.eContainer() == null)
				return null;
			
			current = current.eContainer();
		}
		return (T)current;
	}
	
	public static EditorGTFile getGTFile(EObject node) {
		EObject current = node;
		while(!(current instanceof EditorGTFile)) {
			if(node.eContainer() == null)
				return null;
			
			current = current.eContainer();
		}
		return (EditorGTFile)current;
	}
}
