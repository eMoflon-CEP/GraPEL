/*
 * generated by Xtext 2.20.0
 */
package org.emoflon.cep.scoping;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.emoflon.cep.grapel.ApplyStatement;
import org.emoflon.cep.grapel.AttributeConstraint;
import org.emoflon.cep.grapel.AttributeExpression;
import org.emoflon.cep.grapel.EditorGTFile;
import org.emoflon.cep.grapel.EnumLiteral;
import org.emoflon.cep.grapel.Event;
import org.emoflon.cep.grapel.EventAttribute;
import org.emoflon.cep.grapel.EventPattern;
import org.emoflon.cep.grapel.EventPatternContextConstraint;
import org.emoflon.cep.grapel.EventPatternNode;
import org.emoflon.cep.grapel.EventPatternNodeAttributeExpression;
import org.emoflon.cep.grapel.EventPatternNodeExpression;
import org.emoflon.cep.grapel.GrapelPackage;
import org.emoflon.cep.grapel.MatchEventState;
import org.emoflon.cep.grapel.RelationalConstraint;
import org.emoflon.cep.grapel.ReturnApply;
import org.emoflon.cep.grapel.ReturnSpawn;
import org.emoflon.cep.grapel.SpawnStatement;
import org.emoflon.cep.grapel.impl.EventPatternImpl;
import org.emoflon.ibex.gt.editor.gT.EditorEnumExpression;
import org.emoflon.ibex.gt.editor.gT.EditorNode;
import org.emoflon.ibex.gt.editor.gT.EditorPattern;
import org.emoflon.ibex.gt.editor.utils.GTEditorModelUtils;
import org.emoflon.ibex.gt.editor.utils.GTEditorPatternUtils;
import org.emoflon.ibex.gt.editor.utils.GTEnumExpressionHelper;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class GrapelScopeProvider extends AbstractGrapelScopeProvider {
	
	/**
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the reference in the given context
	 */
	public IScope getScopeInternal(EObject context, EReference reference) {
		// Events
	    if (isEvent(context, reference)) {
	    	return getScopeForEvents((Event)context);
	    }
	    
	    // Enum
	    if (isEnumLiteralExpression(context)) {
	    	return getScopeForEnumLiterals((EnumLiteral)context);
	    }
	    
	    // EventAttributes
	    if (isEventAttribute(context, reference)) {
	    	return getScopeForEventAttributes((EventAttribute)context);
		}
	    // EventPatterns
	    if (isEventPattern(context, reference)) {
	    	return getScopeForEventPatterns((EventPattern)context, reference);
		}
	    // EventPatternReturnTypes
	    if (isReturnSpawn(context, reference)) {
	    	return getScopeForReturnSpawn((ReturnSpawn)context);
		}
	    if (isReturnApply(context, reference)) {
	    	return getScopeForReturnApply((ReturnApply)context);
		}
	    if (isSpawnStatement(context, reference)) {
	    	return getScopeForSpawnStatement((SpawnStatement)context);
	    }
	    if (isApplyStatementArg(context, reference)) {
	    	return getScopeForApplyStatementArg((ApplyStatement)context);
	    }
	    if (isApplyStatementMatch(context, reference)) {
	    	return getScopeForApplyStatementMatch((ApplyStatement)context);
	    }
	    // EventPatternNodes
	    if (isEventPatternNode(context, reference)) {
	    	return getScopeForEventPatternNodes((EventPatternNode)context);
		}
	    // EventPatternContextConstraints
	    if (isEventPatternContextConstraint(context, reference)) {
	    	return getScopeForEventPatternContextConstraintNodes((EventPatternContextConstraint)context);
		}
	    // EventPatternNodeExpression
	    if (isEventPatternNodeExpression(context, reference)) {
	    	return getScopeForEventPatternNodeExpressions((EventPatternNodeExpression)context, reference);
		}
	    // EventPatternNodeAttributeExpressionField
	    if (isEventPatternNodeAttributeExpressionAttributeField(context, reference)) {
	    	return getScopeForEventPatternNodeAttributeExpressionAttributeFields((EventPatternNodeAttributeExpression)context, reference);
		}
	    // EventPatternRelationalConstraint
	    if (isRelationalConstraint(context)) {
	    	return getScopeRelationalConstraints((RelationalConstraint)context);
		}
	    // MatchEventState
	    if(context instanceof MatchEventState) {
	    	return getScopeForMatchEventState((MatchEventState)context);
	    }
	    // AttributeConstraint
	    if (isGrapelAttributeConstraint(context, reference)) {
	    	return getScopeForGrapelAttributeConstraints((AttributeConstraint)context, reference);
		}
	    // AttributeExpression
	    if (isGrapelAttributeExpression(context, reference)) {
	    	return getScopeForGrapelAttributeExpressions((AttributeExpression)context, reference);
		}
	    
	    return super.getScope(context, reference);
	}
	
	// enum scope
	/**
	 * @param context the enum from which an element shall be referenced
	 * @return the scope for the given enum literal
	 */
	private IScope getScopeForEnumLiterals(EnumLiteral context) {
		EditorGTFile gtFile = getGTFile(context);
		return Scopes.scopeFor(GTEditorModelUtils.getEnums(gtFile).stream().flatMap(eenum -> eenum.getELiterals().stream()).collect(Collectors.toList()));
	}

	/**
	 * @param context the element to check for being an enum literal expression
	 * @return true, if the context is an instance of an enum literal
	 */
	private boolean isEnumLiteralExpression(EObject context) {
		return context instanceof EnumLiteral;
	}
	
	// general scope
	@Override
	public IScope getScope(EObject context, EReference reference) {	
		try {
			return getScopeInternal(context, reference);
		} catch(Exception e) {
			e.printStackTrace();
			return super.getScope(context, reference);
		}
	}
	
	// match scope
	/**
	 * @param context the match event from which an element shall be referenced
	 * @return the scope for the given match event state
	 */
	private IScope getScopeForMatchEventState(MatchEventState context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(GTEditorPatternUtils.getContainer(context, EventPatternImpl.class).getNodes().stream()
				.filter(node -> (node.getType() instanceof EditorPattern))
				.collect(Collectors.toList()));
		return Scopes.scopeFor(scope);
	}
	
	// event pattern node expression scope
	/**
	 * @param context the event pattern node expression from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the given event pattern node expression and the reference
	 */
	private IScope getScopeForEventPatternNodeExpressions(EventPatternNodeExpression context, EReference reference) {
		Collection<EObject> scope = new HashSet<>();
		
		if(reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_EXPRESSION__PATTERN_NODE) {
			EventPattern ePattern = GTEditorPatternUtils.getContainer(context, EventPatternImpl.class);
			scope.addAll(ePattern.getNodes());
		}
		
		if(reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_EXPRESSION__ATTRIBUTE) {
			if(context.getPatternNode() == null)
				return super.getScope(context, reference);
			if(context.getPatternNode().getType() instanceof Event) {
				Event event = (Event)context.getPatternNode().getType();
				scope.addAll(event.getAttributes());
			}else {
				EditorPattern pattern = (EditorPattern) context.getPatternNode().getType();
				scope.addAll(pattern.getNodes());
			}
		}
		
		
		return Scopes.scopeFor(scope);
	}
	
	/**
	 * @param context the element to check for being an event pattern node expression
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event pattern node expression
	 */
	private boolean isEventPatternNodeExpression(EObject context, EReference reference) {
		return (context instanceof EventPatternNodeExpression);
	}
	
	// attribute expression scope
	/**
	 * @param context the attribute expression from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the given attribute expression
	 */
	private IScope getScopeForGrapelAttributeExpressions(AttributeExpression context, EReference reference) {
		return Scopes.scopeFor(GTEditorPatternUtils.getContainer(context, EventPatternImpl.class).getNodes());
	}

	/**
	 * @param context the element to check for being an attribute expression
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an attribute expression
	 */
	private boolean isGrapelAttributeExpression(EObject context, EReference reference) {
		 return (context instanceof AttributeExpression);
	}
	
	// spawn/apply scope
	/**
	 * @param context the element to check for being a return spawn
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of a return spawn and the reference is to the return spawn return type 
	 */
	private boolean isReturnSpawn(EObject context, EReference reference) {
		 return (context instanceof ReturnSpawn && reference == GrapelPackage.Literals.RETURN_SPAWN__RETURN_TYPE);
	}
	
	/**
	 * @param context the element to check for being a return apply
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of a return apply and the reference is to the return apply return type 
	 */
	private boolean isReturnApply(EObject context, EReference reference) {
		 return (context instanceof ReturnApply && reference == GrapelPackage.Literals.RETURN_APPLY__RETURN_TYPE);
	}
	
	/**
	 * @param context the return spawn element from which an element shall be referenced
	 * @return the scope for the given return spawn
	 */
	private IScope getScopeForReturnSpawn(ReturnSpawn context) {
		return Scopes.scopeFor(getGTFile(context).getEvents());
	}
	
	/**
	 * @param context the return apply element from which an element shall be referenced
	 * @return the context for the given return apply
	 */
	private IScope getScopeForReturnApply(ReturnApply context) {
		return Scopes.scopeFor(getGTFile(context).getPatterns().stream()
				.filter(pattern -> GTEditorPatternUtils.containsCreatedOrDeletedElements(pattern))
				.collect(Collectors.toList()));
	}
	
	/**
	 * @param context the element to check for being a spawn statement
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of a spawn statement and the reference is a spawn statement return argument
	 */
	private boolean isSpawnStatement(EObject context, EReference reference) {
		 return (context instanceof SpawnStatement && reference == GrapelPackage.Literals.SPAWN_STATEMENT__RETURN_ARG);
	}
	
	/**
	 * @param context the spawn statement from which an element shall be referenced
	 * @return the scope for the given spawn statement
	 */
	private IScope getScopeForSpawnStatement(SpawnStatement context) {
		EventPattern eventPattern = (EventPattern)context.eContainer();
		if(eventPattern.getReturnType() != null && eventPattern.getReturnType() instanceof ReturnSpawn) {
			ReturnSpawn spawn = (ReturnSpawn)eventPattern.getReturnType();
			return Scopes.scopeFor(Arrays.asList(new EObject[]{spawn.getReturnType()}));
		} else if(eventPattern.getReturnType() != null && eventPattern.getReturnType() instanceof ReturnApply) {
			Scopes.scopeFor(new LinkedList<>());
		}
		return Scopes.scopeFor(getGTFile(context).getEvents());
	}
	
	/**
	 * @param context the element to check for being an apply statement argument
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an apply statement and the reference is an apply statement return argument
	 */
	private boolean isApplyStatementArg(EObject context, EReference reference) {
		 return (context instanceof ApplyStatement && reference == GrapelPackage.Literals.APPLY_STATEMENT__RETURN_ARG);
	}
	
	/**
	 * @param context the element to check for being an apply statement match
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an apply statement and the reference is an apply statement match
	 */
	private boolean isApplyStatementMatch(EObject context, EReference reference) {
		 return (context instanceof ApplyStatement && reference == GrapelPackage.Literals.APPLY_STATEMENT__MATCH);
	}
	
	/**
	 * @param context the apply statement from which the apply statement argument shall be referenced
	 * @return the scope for the given apply statement
	 */
	private IScope getScopeForApplyStatementArg(ApplyStatement context) {
		EventPattern eventPattern = (EventPattern)context.eContainer();
		if(eventPattern.getReturnType() != null && eventPattern.getReturnType() instanceof ReturnApply) {
			ReturnApply spawn = (ReturnApply)eventPattern.getReturnType();
			return Scopes.scopeFor(Arrays.asList(new EObject[]{spawn.getReturnType()}));
		} else if(eventPattern.getReturnType() != null && eventPattern.getReturnType() instanceof ReturnSpawn) {
			Scopes.scopeFor(new LinkedList<>());
		}
		return Scopes.scopeFor(getGTFile(context).getPatterns().stream()
				.filter(pattern -> GTEditorPatternUtils.containsCreatedOrDeletedElements(pattern))
				.collect(Collectors.toList()));
	}
	
	/**
	 * @param context the apply statement from which the apply statement match shall be referenced
	 * @return the scope for the given apply statement
	 */
	private IScope getScopeForApplyStatementMatch(ApplyStatement context) {
		EventPattern eventPattern = (EventPattern)context.eContainer();
		return Scopes.scopeFor(eventPattern.getNodes().stream()
				.filter(node -> node.getType() instanceof EditorPattern)
				.filter(node -> node.getType().equals(context.getReturnArg()))
				.collect(Collectors.toList()));
	}
	
	// constraint scope
	/**
	 * @param context the attribute from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the given GrapeL attribute constraints
	 */
	private IScope getScopeForGrapelAttributeConstraints(AttributeConstraint context, EReference reference) {
		return Scopes.scopeFor(GTEditorPatternUtils.getContainer(context, EventPatternImpl.class).getNodes());
	}
	
	/**
	 * @param context the element to check for being an attribute constraint
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an attribute constraint
	 */
	private boolean isGrapelAttributeConstraint(EObject context, EReference reference) {
		return (context instanceof AttributeConstraint);
	}
	
	/**
	 * @param context the relational constraint from which an element shall be referenced
	 * @return the scope for the given relational constraint
	 */
	private IScope getScopeRelationalConstraints(RelationalConstraint context) {
		EventPattern ePattern = GTEditorPatternUtils.getContainer(context, EventPatternImpl.class);
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(ePattern.getNodes());
		return Scopes.scopeFor(scope);
	}
	
	/**
	 * @param context the element to check for being an relational constraint
	 * @return true, if the context is an instance of an relational constraint
	 */
	private boolean isRelationalConstraint(EObject context) {
		return (context instanceof RelationalConstraint);
	}
	
	/**
	 * @param context the event pattern node attribute expression from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the the given event pattern node attribute expression
	 */
	private IScope getScopeForEventPatternNodeAttributeExpressionAttributeFields(
			EventPatternNodeAttributeExpression context, EReference reference) {
		Collection<EObject> scope = new HashSet<>();

		if(context.getNodeExpression() == null)
			return super.getScope(context, reference);
		if(context.getNodeExpression().getPatternNode() == null)
			return super.getScope(context, reference);
		if(context.getNodeExpression().getAttribute() == null)
			return super.getScope(context, reference);
		if(context.getNodeExpression().getAttribute().eContainer() == null)
			return super.getScope(context, reference);
		
		if(context.getNodeExpression().getPatternNode().getType() instanceof Event) {
			EventAttribute attribute = (EventAttribute)context.getNodeExpression().getAttribute();
			
			if(attribute.getType() instanceof EDataType)
				return super.getScope(context, reference);
			
			EClass clazz = (EClass)attribute.getType();
			scope.addAll(clazz.getEAllAttributes());
		}else {
			EditorNode node = (EditorNode) context.getNodeExpression().getAttribute();
			scope.addAll(node.getType().getEAllAttributes());
		}
		return Scopes.scopeFor(scope);
	}
	
	/**
	 * @param context the element to check for being an attribute expression attribute field
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event pattern node attribute expression and the reference is an attribute expression field
	 */
	private boolean isEventPatternNodeAttributeExpressionAttributeField(EObject context, EReference reference) {
		return (context instanceof EventPatternNodeAttributeExpression 
				&& reference == GrapelPackage.Literals.EVENT_PATTERN_NODE_ATTRIBUTE_EXPRESSION__FIELD);
	}
	
	/**
	 * @param context the event pattern context constraint from which an element shall be referenced
	 * @return the scope for the given event pattern context constraint
	 */
	private IScope getScopeForEventPatternContextConstraintNodes(EventPatternContextConstraint context) {
		return Scopes.scopeFor(((EventPattern)context.eContainer()).getNodes());
	}
	
	/**
	 * @param context the element to check for being an event pattern context constraint
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event pattern context constraint
	 */
	private boolean isEventPatternContextConstraint(EObject context, EReference reference) {
		return (context instanceof EventPatternContextConstraint);
	}
	
	// event scope
	/**
	 * @param context the element to check for being an event
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event
	 */
	protected boolean isEvent(EObject context, EReference reference) {
	    return (context instanceof Event);
	}
	
	/**
	 * @param context the event from which an element shall be referenced
	 * @return the scope for the given event
	 */
	protected IScope getScopeForEvents(Event context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(GTEditorModelUtils.getClasses(getGTFile(context)));
		scope.addAll(GTEditorModelUtils.getDatatypes(getGTFile(context)));
		return Scopes.scopeFor(scope);
	}
	
	/**
	 * @param context the element to check for being an event attribute
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event attribute and the reference is an event attribute
	 */
	protected boolean isEventAttribute(EObject context, EReference reference) {
	    return (context instanceof EventAttribute && reference == GrapelPackage.Literals.EVENT_ATTRIBUTE__TYPE);
	}
	
	/**
	 * @param context the event attribute from which an element shall be referenced
	 * @return the scope for the given event attribute
	 */
	protected IScope getScopeForEventAttributes(EventAttribute context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(GTEditorModelUtils.getClasses(getGTFile(context)));
		scope.addAll(GTEditorModelUtils.getDatatypes(getGTFile(context)));
		return Scopes.scopeFor(scope);
	}
	
	// event pattern scope
	/**
	 * @param context the element to check for being an event pattern
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event pattern and the reference is an event pattern return
	 */
	protected boolean isEventPattern(EObject context, EReference reference) {
	    return (context instanceof EventPattern && reference != GrapelPackage.Literals.EVENT_PATTERN__RETURN_TYPE);
	}
	
	/**
	 * @param context the event pattern from which an element shall be referenced
	 * @param reference the reference for which to get the scope
	 * @return the scope for the given event pattern
	 */
	protected IScope getScopeForEventPatterns(EventPattern context, EReference reference) {
		return Scopes.scopeFor(context.getNodes());
	}
	
	// event pattern node scope
	/**
	 * @param context the element to check for being an event pattern node
	 * @param reference the reference for which to check the scope type
	 * @return true, if the context is an instance of an event pattern node and the reference is an event pattern node
	 */
	protected boolean isEventPatternNode(EObject context, EReference reference) {
	    return (context instanceof EventPatternNode && reference == GrapelPackage.Literals.EVENT_PATTERN_NODE__TYPE);
	}
	
	/**
	 * @param context the event pattern node from which an element shall be referenced
	 * @return the scope for the given event pattern node
	 */
	protected IScope getScopeForEventPatternNodes(EventPatternNode context) {
		Collection<EObject> scope = new HashSet<>();
		scope.addAll(getGTFile(context).getPatterns());
		scope.addAll(getGTFile(context).getEvents());
		return Scopes.scopeFor(scope);
	}
	
	// enum scope
	@Override
	public IScope getScopeForEnumLiterals(EditorEnumExpression enumExpression) {
		EEnum type = (EEnum)GTEnumExpressionHelper.getEnumDataType(enumExpression);
		if (type != null && type instanceof EEnum) {
			return Scopes.scopeFor(type.getELiterals());
		} else {
			EditorGTFile gtFile = getGTFile(enumExpression);
			return Scopes.scopeFor(GTEditorModelUtils.getEnums(gtFile).stream()
					.flatMap(e -> e.getELiterals().stream())
					.collect(Collectors.toList()));
		}

	}
	
	/**
	 * @param node included in editor file
	 * @return the GT editor file, which includes the node
	 */
	public static EditorGTFile getGTFile(EObject node) {
		EObject current = node;
		while(!(current instanceof EditorGTFile)) {
			if(node.eContainer() == null)
				return null;
			
			current = current.eContainer();
		}
		return (EditorGTFile)current;
	}
}
